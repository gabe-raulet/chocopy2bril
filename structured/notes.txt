1.1. The top level

    "A ChocoPy program consists of zero or more definitions followed by zero or more statements, referred to
     as top-level definitions and statements respectively. Top-level definitions include global variable definitions
     and function definitions. These definitions create new mappings in a scope called the global scope. Global variables
     are defined using the syntax {id}:{type} = {literal}, where the identifier specifies the variable name, the type annotation
     specifies the static type of the variable, and the constant literal specifies the initial value of the variable upon
     program execution. Top-level statements execute in the global scope; that is, expressions in top-level statements may
     reference entities defined in the global scope using identifiers. A ChocoPy program's execution begins with a top-level
     statement and ends when the last top-level statement is executed completely."

    In Bril intermediate representation, we must have a main function which defines the entry and exit point of a Bril program.
    It is therefore natural to associate the main function in bril with the top-level of ChocoPy. All global variable definitions
    are therefore member variables of the main function. By "member variables," we mean all variables associated with the given
    scope. In our case, there are basically two different kinds of scopes: global scope (associated just with the top-level/main function)
    and various local scopes associated with each function definition. For now, we are not supporting nested function definitions,
    which means that all function definitions must belong at the top-level of a ChocoPy program.

1.2. Functions

    "A function definition has the following form:

        def {id}({id}: {type}, ..., {id}: {type}) {return type}:
            {declarations}
            {stmts}

     where {return type} is either empty or has the form -> {type}. The first line defines the function's name, a comma-separated list of
     zero or more formal parameters in parentheses, and the function's return type after the -> symbol.

     Declarations in a function body include local variable definitions, global and nonlocal variable declarations, and definitions of
     nested functions. {id}:{type} = {literal}. Such a definition declares a local variable with the name id, explicitly associates it
     with a static type, and specifies an initial value using a literal.
    "

1.3. Expressions


    "ChocoPy supports the following categories of expressions: literals, identifiers, arithmetic expressions, logical expressions,
     relational expressions, and call expressions."

1.3.1. Literals and identifiers

    "The basic expression is a constant literal or a variable. Literals can have types bool or int. Variables evaluate to the value
     contained in the variable."

1.3.2. Arithmetic expressions

    "ChocoPy supports the following arithmetic expressions on two operands each of type int: {expr} + {expr}, {expr} - {expr},
     {expr} * {expr}, {expr} // {expr}, and {expr} % {expr}. These operators perform integer addition, subtraction, multiplication,
     division quotient, and division remainder, respectively. The unary expression -{expr} evaluates to the negative of the integer-valued
     operand. Arithmetic operations return an int value."

1.3.3. Logical expressions

    "ChocoPy supports the following logical operations on operands of type bool: not {expr}, {expr} and {expr}, and {expr} or {expr},
     which evaluate to the logical negation, conjunction, and disjunction of their operands, respectively. Logical expressions return
     a bool value. The binary logical expressions are also short-circuiting. If the left operand of an and expression evaluates to False,
     then a result of False is returned without evaluating the right operand at all. Similarly, if the left operand of an or expression
     evaluates to True, then a result of True is returned without evaluating the right operand at all. These semantics are important
     when the expressions in the right-hand side operands contain side-effects."

1.3.4. Relational expressions

    "ChocoPy supports the following relational expressions on operands of type int: {expr} < {expr}, {expr} <= {expr}, {expr} > {expr},
     {expr} > {expr}, {expr} >= {expr}. Additionally, the operands in the expressions of the form {expr} == {expr} and {expr} != {expr}
     can be of types int or bool, as long as both operands are of the same type."


1.3.5. Conditional expressions

    "The expression {expr1} if {expr0} else {expr2} first evaluates {expr0}, which must have type bool. If the result is True, then
     {expr1} is evaluated and its result is the value of the expression. Otherwise, {expr2} is evaluated and its value is the value of
     the expression."

1.3.6. Call expressions

    "A call expression is of the form {id}({expr}, ...), where {expr},... is a comma-separated list of zero or more expresions provided
     as arguments to the call".


1.4. Statements

