The parser begins by parsing top-level declarations (get_decls. Top-level declarations
include global variable definitions and function definitions. A loop is entered which
determines whether the given logical line matches a typed_var production {id}:{type},
or the beginning of a func_def production def {id}(. The loop parses each kind of
production either there are no more lines in the program or a logical line is reached
which is neither of the previous two productions.

For each logical line that matches a typed_var production, we parse the line as:

    {id} : {type} = {literal} NEWLINE

and return a dictionary {"name" : {id}, "type" : {type}, "init" : {literal}}.
This dictionary represents a global variable whose name is {id}, type is {type},
and initialized literal value is {literal}. A {literal} is

###################################

program ::= {var_def | func_def}* stmt*
typed_var ::= ID : type
type ::= "int" | "bool"
func_def ::= "def" ID ( {typed_var{, typed_var}*}?) {-> type}? : NEWLINE INDENT func_body DEDENT
func_body ::= {var_def}* stmt+
var_def ::= typed_var = literal NEWLINE
stmt ::= simple_stmt NEWLINE
simple_stmt ::= "pass" | expr | return {expr}? | ID = expr
literal ::= "None" | "True" | "False" | NUM
expr ::= ID | literal | call_expr
call_expr ::= ID ({expr{, expr}*}?)

###################################
