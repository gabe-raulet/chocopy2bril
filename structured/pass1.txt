Implementing the parser in multiple passes for now. The first pass does minimal processing
and just makes sure that the basic syntax is respected, without worrying about type mismatching
or use of non-existant variables etc.

The entire program is parsed using the following grammar:

    program ::= {var_def | func_def}* stmt*

    var_def ::= typed_var = literal NEWLINE
    func_def ::= "def" ID ({typed_var {, typed_var}*}?) {-> type}? : NEWLINE INDENT var_def* stmt+ DEDENT

    stmt ::= {pass_stmt | print_stmt | return_stmt | assign_stmt | expr} NEWLINE
    pass_stmt ::= "pass"
    print_stmt ::= "print" (expr)
    return_stmt ::= "return" {expr}?
    assign_stmt ::= ID = expr

    expr ::= call_expr | literal | ID
    call_expr ::=  ID ({expr {, expr}*}?)

    typed_var ::= ID : type
    type ::= "int" | "bool"
    literal ::= "None" | BOOL | NUM

In the first pass, we parse productions into the following json objects:

    stmt ::= {pass_stmt | print_stmt | return_stmt | assign_stmt | expr}
    expr ::= call_expr | literal | ID

    program = {
        "func_defs"? : List[func_def],
         "var_defs"? : List[var_def],
            "stmts"? : List[stmt]
        }

    func_def = {
             "name" : ID,
            "stmts" : List[stmt],
          "params"? : List[typed_var],
        "var_defs"? : List[var_def],
            "type"? : type
        }

    var_def = {
        "typed_var" : typed_var,
          "literal" : literal
        }

    pass_stmt = {
            "stmt" : "pass"
        }

    print_stmt = {
            "stmt" : "print",
            "expr" : expr
        }

    return_stmt = {
            "stmt"  : "return",
            "expr"? :  expr
        }

    assign_stmt = {
            "stmt" : "assign",
            "dest" : ID,
            "expr" : expr
        }

    call_expr = {
            "call"  : ID,
            "args"? : List[expr]
        }

    typed_var = {
              "id" : ID,
            "type" : type
        }

    literal = {
            "value" : None | BOOL | NUM,
            "type"? : type
        }

